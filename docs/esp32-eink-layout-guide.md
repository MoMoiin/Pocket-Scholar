# ESP32 E-Ink Layout Guide

## 1. What You Are Building
- A modular rendering pipeline for the Pocket-Scholar e-ink front end that runs on an ESP32 using the GxEPD2 driver stack.
- Each screen (loading, home, flashcards, etc.) draws into a full-frame buffer before triggering an e-ink refresh so updates stay clean and predictable.

## 2. Hardware & Library Prerequisites
1. ESP32 development board with exposed SPI pins.
2. GDEH0213B74 (2.13" b/w) or compatible panel wired to `CS`, `DC`, `RST`, and `BUSY` pins defined in `include/Display/DisplayManager.h:11`.
3. PlatformIO project configured with `GxEPD2`, `Adafruit_GFX`, and `U8g2_for_Adafruit_GFX` as declared in `platformio.ini`.
4. Optional tools: image2cpp (web), LCD Image Converter, GIMP, or Inkscape for generating 1-bit icon assets.

## 3. Project Initialization Workflow
1. Wire the panel to the ESP32 using level-appropriate voltages (3.3 V logic) and double-check BUSY orientation.
2. In PlatformIO run `pio run` once to pull dependencies and compile the default firmware.
3. Flash the device to verify the existing loading screen renders without artifacts.

## 4. Display Pipeline Basics
- `DisplayManager::init()` (`src/Display/DisplayManager.cpp:9`) sets rotation, clears the screen, and primes the U8g2 adapter.
- Every drawing pass must live inside the `firstPage()`/`nextPage()` loop. The loading screen implementation at `src/Display/DisplayManager.cpp:60` is your template.
- Call `displayManager.refresh(false)` for a full-screen update or `refresh(true)` for partial updates after drawing operations complete.

## 5. Screen Architecture Pattern
1. Create a lightweight base class, e.g. `BaseScreen`, with a `render(DisplayManager&)` virtual method.
2. Store the shared `DisplayManager` instance (`src/Display/DisplayManager.cpp:4`) and pass it to each screen.
3. On a state change (e.g. different menu selection) choose the appropriate screen object and call its `render()` from the main loop.
4. Keep UI state (current flashcard, Wi-Fi status) in plain structs so screens can remain declarative.

## 6. Layout Process Step-by-Step
1. **Collect data**: gather the values you need (strings, progress, icons).
2. **Declare regions**: decide on bounding boxes for header, body, footer. Use `displayManager.width()`/`height()` (`src/Display/DisplayManager.cpp:165`) to keep calculations dynamic.
3. **Clear background**: use `fillRect()` for partial windows or `fillScreen()` for fresh layouts.
4. **Draw static decorations**: frames, dividing lines, icons. `drawRect()` and `drawBitmap()` are already wrapped in the manager.
5. **Compute text positions**: leverage `getTextBounds()` like the loading screen does to center or right-align copy.
6. **Render dynamic text**: `setCursor()` then `println()` for ASCII; swap to U8g2 (`setU8g2Font()` + `printlnUTF8()`) when you need UTF-8 glyphs.
7. **Trigger refresh**: pass `false` for full-screen sweeps; `true` when only a bounded region changed and `setPartialWindow()` was used.

## 7. Asset Preparation (Icons & Fonts)
- For custom icons, start with a clean SVG/PNG (ideally a simple monochrome shape).
- Convert to a 1-bit array:
  1. Load the image into your conversion tool and set output size in pixels.
  2. Choose horizontal byte order (LSB first) for GxEPD2 compatibility.
  3. Export as a `const uint8_t` array.
- Store assets in PROGMEM to conserve RAM:
```cpp
// include/Display/Icons.h
#pragma once
#include <pgmspace.h>

const uint8_t PROGMEM WIFI_ICON_24x24[] = {
    /* generated bytes */
};
```
- Draw with `displayManager.drawBitmap(x, y, WIFI_ICON_24x24, 24, 24, GxEPD_BLACK);` and refresh.
- If you only need glyph-style icons, load an icon font via `displayManager.setU8g2Font(myFont);` and print the character.

## 8. Partial vs Full Refresh Strategy
- Use full refresh when the entire layout changed or after several partial updates to remove ghosting.
- Partial refresh flow:
  1. Call `setPartialWindow(x, y, w, h)` (`src/Display/DisplayManager.cpp:93`).
  2. Redraw only the content inside that window.
  3. Call `refresh(true)` to minimize flicker and speed up the exchange.
- Track dirty regions in your screen controller so you only redraw what changed.

## 9. Testing & Troubleshooting
- **Ghosting/Banding**: force a full refresh every few minutes or after eight partial updates.
- **Missing text**: confirm the target font includes your characters; for UTF-8 ensure you switched to U8g2 rendering (`src/Display/DisplayManager.cpp:129`).
- **Inverted colors**: remember that e-ink defaults to white-on-black; fill with `GxEPD_WHITE` before drawing black content.
- **Slow updates**: reduce the number of draw calls inside the `firstPage()` loop and favor integer math for layout calculations.

## 10. Suggested Next Actions
1. Draft a `BaseScreen` class and migrate the loading screen logic into its own implementation.
2. Create an `Icons.h` header with at least one converted bitmap and render it in a test screen.
3. Add a simple home screen layout that prints a title, subtitle, and icon, then schedule partial updates for changing data (e.g. progress indicator).
4. Document any new screen in this guide so future contributors can follow the same process.
